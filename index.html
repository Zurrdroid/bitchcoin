<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Petalfall</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
		
			// Declaration
			let scene, camera, renderer, container;
		
			let spread = new THREE.Vector3(20, 20, 15);
			let yzSkew = 2;
			let xzSkew = 4;
			let center = [0, 0, 0];
			let fallSpeed = 0.005;
			let turnSpeed = 0.002;
			let petalCount = 200;
			
			const petals = [];
			
			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;
			
			// Cache variables
			let lastScrollY = 0;
			let currentScrollY = 0;
			let mouseX = 0;
			let mouseXLast = 0;
			let mouseY = 0;
			let mouseYLast = 0;
			
			// Flags
			mouseAlreadyMoved = false;
			
			// Initialize scene and start animation
			init();
			animate();
			
			function init() {
				
				// Setting up scene, camera, and renderer
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 100);
				camera.position.z = 15;
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight); // Might need to switch this up based on the div size or whatever else is required.
				
				// Adding renderer to DOM
				document.body.appendChild(renderer.domElement);
				
				// Setting up defaults
				lastScrollY = currentScrollY = window.scrollY;
				
				const geometry = new THREE.PlaneBufferGeometry(1, 1);
				geometry.attributes.position.setZ(2, 0.5);
				geometry.computeVertexNormals();
				geometry.attributes.position.needsUpdate = true;
				
				const textureLoader = new THREE.TextureLoader();

				// Create materials for each petal sprite
				const sprite1 = textureLoader.load('img/petalA.png');
				const material1 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite1 });
				const sprite2 = textureLoader.load('img/petalB.png');
				const material2 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite2 });
				const sprite3 = textureLoader.load('img/petalC.png');
				const material3 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite3 });
				const sprite4 = textureLoader.load('img/petalD.png');
				const material4 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite4 });
				const sprite5 = textureLoader.load('img/petalE.png');
				const material5 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite5 });
				const sprite6 = textureLoader.load('img/petalF.png');
				const material6 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite6 });
				const sprite7 = textureLoader.load('img/petalG.png');
				const material7 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite7 });
				const sprite8 = textureLoader.load('img/petalH.png');
				const material8 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite8 });
				const sprite9 = textureLoader.load('img/petalI.png');
				const material9 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite9 });
				const sprite10 = textureLoader.load('img/petalJ.png');
				const material10 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite10 });
				const sprite11 = textureLoader.load('img/petalK.png');
				const material11 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite11 });
				const sprite12 = textureLoader.load('img/petalL.png');
				const material12 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite12 });
				const sprite13 = textureLoader.load('img/petalM.png');
				const material13 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite13 });
				const sprite14 = textureLoader.load('img/petalN.png');
				const material14 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite14 });
				const sprite15 = textureLoader.load('img/petalO.png');
				const material15 = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, map: sprite15 });
				
				mats = [material1, material2, material3, material4, material5, material6, material7, material7, material9, material10, material11, material12, material3, material14, material15];
				
				// Generate random petals
				for ( let i = 0; i < petalCount; i ++ ) {

					const material = mats[Math.floor(Math.random() * mats.length)];
					const mesh = new THREE.Mesh(geometry, material);
					const zRand = Math.random();

					mesh.position.z = spread.z * ((zRand*zRand*zRand) - 0.5) + center[2]; // Random^3 so that more petals will spawn further away
					mesh.position.y = spread.y * ((mesh.position.z - camera.position.z)/spread.z) * yzSkew * (Math.random() - 0.5) + center[1];
					mesh.position.x = spread.x * ((mesh.position.z - camera.position.z)/spread.z) * xzSkew * (Math.random() - 0.5) + center[0];

					//mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() + 0.5;
					mesh.rotation.x = Math.random() * Math.PI * 2;
					mesh.rotation.y = Math.random() * Math.PI * 2;
					mesh.rotation.z = Math.random() * Math.PI * 2;

					scene.add(mesh);

					petals.push(mesh);

				}

				scene.fog = new THREE.Fog(0, spread.z/1.2, spread.z*1.5);
				
				// Event Listeners
				document.addEventListener( 'mousemove', onDocumentMouseMove );
				document.addEventListener( 'scroll', onScroll );
			}
			
			function onDocumentMouseMove( event ) {

				mouseX = (event.clientX - windowHalfX)/100;
				mouseY = (event.clientY - windowHalfY)/100;
				
				if (!mouseAlreadyMoved) {
					// TODO: Do something to record Mouse Delta here...
					mouseXLast = mouseX;
					mouseYLast = mouseY;
					mouseAlreadyMoved = true;
				}

			}
			
			function onScroll(event) {
				currentScrollY = window.scrollY;
			}

			function animate() {
				requestAnimationFrame(animate);
				
				// TODO: Handle scrolling...
				let scrollMultiplier = 0;
				if (lastScrollY != currentScrollY) {
					scrollMultiplier = -(currentScrollY - lastScrollY)*fallspeed*20;
					lastScrollY = currentScrollY;
				}
				
				const mousePoint = new THREE.Vector3(mouseX, -mouseY, 0);
				let petalDist = 0;
				let boundTop = spread.y/2;
				let boundBottom = -spread.y/2;
				let boundLeft = -spread.x/2;
				let boundRight = -spread.x/2;
				var petalDir;
				
				for (let i = 0; i < petals.length; i++) {
					
					petals[i];
				
					petals[i].rotation.x += turnSpeed;
					petals[i].rotation.y += turnSpeed;
					petals[i].rotation.z += turnSpeed;
					
					//petal.position.z = -petal.position.y < -spread/2 ? -spread/2 : -petal.position.z + fallspeed*5;
					
					// Handle vertical petal movement
					// TODO: Scrolling too fast can cause gaps to appear, need to solve this
					boundTop = (spread.y/2) * (-(petals[i].position.z - camera.position.z)/spread.z) * yzSkew;
					boundBottom = -boundTop;
					
					while (petals[i].position.y > boundTop) {
						petals[i].position.y -= boundTop - boundBottom;
					}
					while (petals[i].position.y < boundBottom) {
						petals[i].position.y += boundTop - boundBottom;
					}
					petals[i].position.y -= (fallSpeed + scrollMultiplier);
					
					// TODO: Handle cursor-based petal movement
					petalDist = petals[i].position.distanceToSquared(mousePoint);
					if (petalDist < 2500000000) {
						petalDir = petals[i].position.clone();
						petalDir.sub(mousePoint);
						petalDir.normalize;
						petals[i].position = petals[i].position.clone().add(petalDir.multiplyScalar(100));
					}
				}
				
				//petals[0].position.copy(mousePoint.multiplyScalar(2.5)); // petal following mouse
				
				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>